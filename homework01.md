Q.1)Define the term essential difficulties as it is used by Brooks. Provide background and context with your answer and at least one example of an essential difficulty. <br>
Ans:<br>
    Brooks  mentioned that " there is no Silver Bullet in Software Engineering ". That means that there is no single development in software technology like in the field of Hardware, that by itself promises tenfold improvement within a decade.
     Brooks considered the difficulties that we encounter while developing a software product as being divided into two types of categories:<br>
 1. Essential difficulties  <br>
 2. Accidental difficulties <br>
  
 Essential difficulties as defined by Brooks are the ones that are inherent in the nature of the software. This involves the data sets,algorithms,functions and relationship among the data entities. These may be the same in many different representations, but each of them is highly detailed and precise. <br>
 
   Essential difficulties are caused by the problem defintion and if the client wants the software to do something, then the software has to accomplish the required task. For example,  . This represnts one type of essential difficulty.<br>
   
   With a lot of debugging and code refactoring, we can eliminate accidental difficulties(not entirely to zero) but the essential difficulties will always remain in the software. Due to this building a software is always going to be hard and hence comes the notion of No silver bullet being present in the field of software technology.<br>
<br>
Q.2) Define the term accidental difficulties as it is used by Brooks. Provide background and context with your answer and at least one example of an accidental difficulty.<br>
Ans:<br>
   As Brooks divided the difficulties into essential and accidental, let us consider the accidental difficulties:<br>  
   Accidental difficulties are the ones which are related to the production of the software. These are the ones which are created by the engineer who is building the software system and also corrected by the engineer. However while resolving these difficulties with the help of software tools, new ones may arise. So Brooks mentioned that we cannot reduce accidental difficulties to absolute zero.<br>
    
  Most of the tools in software engineering are focussed on resolving these accidental difficulties. According  to Brooks,one technology that had reduced accidental difficulties was the invention of high-level programming languages, such as FortRan.Brooks  also mentiones that reducing the accidental difficulties would not give the same order of improvement as compared to reducing the essential difficulties and thereby the concept of no silver bullet arises as some order of essential difficulties will always sort of persist in the system.<br>
  
  An example of accidental difficulty is: Say we build a mobile application and while using the mobile application the application the host mobile loses a lot of battery power. This can be fixed by an update or iteration in the software. This is an example of accidental difficulty.<br>
  <br>
  Q.3) List and briefly describe the four essential difficulties of developing software systems that Brooks identifies. Provide additional examples of each type of the four essential difficulties.<br>
  Ans:<br>
        The four essential difficulties of developing software systems that Brooks identifies are:<br>
         1. complexity  <br>
         2. conformity <br>
         3. changeability  <br>
         4. invisibility <br>
         Let us discuss all of these in detail:<br>
         1.Complexity:<br>
         While constructing a software , one has to develop a large number of different software entities or subparts of a large software program.If one was developing the same thing then we can reuse it by building a function or method according to object oriented or functional programming. So as the scope of the software increases the number of different entities also increases and also interactions between the different software entities.<br>
         2.Conformity:<br>
         Conformity relates to the essence in which the software is build.Lets say we started building a software application using Python 2.7. However after a certain while, the policies of the company changes and the ne policies supported building software using Python 3.5. So the entire code that has been developed in Python 2.7 has to be changed to Python 3.5. So the software has to conform to the new requirements and these constitute an essential difficulty.
         3.Changeability:<br>
         Software is always destined to change. At any moment of time, software can be improved or be asked to change based on the functions it executes. Change in software requirements can be disastrous in the middle of software development.So this is an essential difficulty. One can avoid this by adopting either an agile framework which supports changes in general or iterative development which changes the software in its next iteration after completing one full iteration of a particular software.<br>
         4.Invisibility:<br>
         The internal structure of a software is very complicated and 
         
         
         
         
  Q.4)Define what Brooks means by a silver bullet and reconstruct his argument as to why he believes there is no silver bullet for software engineering.<br>
  Ans:<br>
  According to Brooks , there are no silver bullets in software engineering. He explained silver bullet as inventions that will do for software productivity, reliability, and simplicity what electronics, transistors, and large-scale integration did for computer hardware. He further states that one cannot expect ever to see twofold gains every two years as happens in hardware according to Moore's law.<br>
  This means that there is no out of the world cure for improving the software gain by one order of magnitude or 10x improvement.This 
 is due to the two types of difficulties:essential and accidental.<br>
    Most tools in software engineering tend to solve the accidental difficulties and try to reduce it to as small as possible. However essential difficulties still remain and they cannot be avoided as it will destroy the essence of software.So considering these two difficulties will always be present one magical cure cannot improve the performance tenfold.
  
  Q.5)In lecture, software engineering's relationship to computer science was described by analogy by discussing the differences between a chemist (chemistry) and a chemical engineer (chemical engineering). Define software engineering and its relationship to computer science; make use of the chemist vs. chemical engineer analogy when answering this question.<br>
  Ans: <br>
  Let us first describe the relationship between a chemist (chemistry) and a chemical engineer (chemical engineering):<br>
  A chemist or field of chemistry gives us the exciting formulas and derivations developed throughout the years. A chemical engineer makes use of these methods in his own personal project in a manner that respects the project requirements. Some of these derivations have to be either combined to form a new derivation or even constrained a bit to achieve the result. For example, limiting the pH level of a substance requires combination of the acid and base in some proportions modeled relative to the outside world pH level.<br>
  Now, software engineering and its relationship to computer science can be defined using the same analogy:<br>
  Computer science is the combination of several concepts such as Operating Systems,Algorithms,Networking,Databases and many more. Each of these facets give fancy stuff that can be used. However in the real world the problem often requires a combination of these concepts and there are some external constraints such as cost which forces us to modify the fancy stuff to suit our goal. Software Engineering is the field which incorporates the requirements or constraints and considering the goal makes use of the fancy stuff in an ideal way.For example: we want to transfer content from one computer to another. This makes use of networking to send the packets via routers. Along with these we may need to incorporate some sort of security mechanism to make sure the packet is received by the intended recipient. We may also need some type of scheduling algorithm at the receiver side. So all these processed together constitute a software and defines the process of software engineering.
   
  Q.6)In lecture, we discussed the importance of the following concepts to software engineers: abstractions, conversations, specification, translation, and iteration. Define each of these concepts as they are related to software engineering and discuss their importance.
    
    
    
 
 
  
    
